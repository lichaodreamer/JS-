<!DOCTYPE html>
<html>
<head>
	<title>粒子线条</title>
	<style type="text/css">
		*{margin: 0px;padding: 0px;}
		body{overflow: hidden;}
		#canvas{
			background-color: #000;
		}
	</style>
</head>
<body>
	<canvas id="canvas"></canvas>
</body>
	<script type="text/javascript">
		//动画
		window.requestAnimFrame=(function(){
			return window.requestAnimationFrame||
			window.webkitRequestAnimationFrame||
			window.mozRequestAnimationFrame||
			function(callback){
				window.setTimeout(callback,1000/60);
			}
		})();
		
		var can=document.getElementById('canvas');
		var cxt=can.getContext("2d");//设置canvas绘图环境
		var w=can.width=window.innerWidth;
		var h=can.height=window.innerHeight;
		var n=300;
		var circles=[];//空数组保存圆形实例
		var mx=100,my=100;
		window.onresize=init;//当浏览器宽高改变时重新执行
		function init(){
			w=can.width=window.innerWidth;
			h=can.height=window.innerHeight;
			circles.lenth=0
			createCircle();
		}
		//绘制一个圆的方法
		function Circle(){
			this.x=Math.random()*w;
			this.y=Math.random()*h;
			this.r=5;
			this.speedX=-0.5+Math.random();
			this.speedY=-0.5+Math.random();//正负0.5
		}
		//添加一个方法
		Circle.prototype.draw=function(){
			cxt.beginPath();//开始路径
			cxt.arc(this.x,this.y,this.r,0,2*Math.PI,false);//值：圆心坐标（x,y),半径，从0~360，逆时针画
			cxt.closePath();//
			cxt.fillStyle="#FFF";
			cxt.fill();//填充方法，绘制一个实心圆
		}
		//更新圆形粒子的坐标
		Circle.prototype.update=function(){
			this.x+=this.speedX;
			this.y+=this.speedY;
			if(this.x<this.r||this.x>w-this.r){
				this.speedX=-this.speedX;
				this.speedY=this.speedY;
			}else if(this.y<this.r||this.y>h-this.r){
				this.speedX=this.speedX;
				this.speedY=-this.speedY;
			}
		}
		//绘制500个圆放到circles数组里
		function createCircle(){
			for(let i=0;i<n;i++){
				circles.push(new Circle());//添加500个
			}
		}
		//首先，先执行一次，方便以后刷新
		createCircle();
		//和鼠标关联上，监听事件
		can.addEventListener("mousemove",function(ev){
			mx=ev.pageX-can.offsetLeft;
			my=ev.pageY-can.offsetTop;
		});
		//绘制出与鼠标位置的相连
		function drawMouse(){
			for(var i=0;i<n;i++)
			{
				if (Math.sqrt((Math.pow((circles[i].x-mx),2))+(Math.pow((circles[i].y-my),2)))<=50){
					drawLine(circles[i].x,circles[i].y,mx,my);
				}
			}
		}
		//让相近的粒子链接起来
		function connectLine(){
			for (var i=0;i<n ;i++ )
			{
				for (var j=0;j<n ;j++ )
				{
					var iCircle=circles[i];
					var jCircle=circles[j];
					if (Math.sqrt((Math.pow((iCircle.x-jCircle.x),2))+(Math.pow((iCircle.y-jCircle.y),2)))<=50)
					{
						drawLine(iCircle.x,iCircle.y,jCircle.x,jCircle.y);
					}
				}
			}
		}
		//封装drawLine()
		function drawLine(x1,y1,x2,y2){
			cxt.beginPath();
			cxt.moveTo(x1,y1);//把触笔移动到什么坐标
			cxt.lineTo(x2,y2);
			cxt.strokeStyle="rgb(8,106,123)";
			cxt.stroke();//空心圆
		}
		//让圆形粒子不断的动起来
		function loop(){
			requestAnimFrame(loop);//递归
			//想清空，再画
			cxt.clearRect(0,0,w,h);
			for(let i=0;i<n;i++){
				circles[i].draw();
				circles[i].update();
			}
			connectLine();
			drawMouse();
		}
		loop();
		// // //绘制曲线
		// cxt.beginPath();//开始路径
		// cxt.arc(w/2,h/2,100,0,2*Math.PI,false);//值：圆心坐标（x,y),半径，从0~360，逆时针画
		// cxt.closePath();//
		// cxt.fillStyle="#FFF";
		// cxt.fill();//填充方法，绘制一个实心圆
		// cxt.strokeStyle="red";
		// cxt.stroke();//空心圆

		// // 画线段
		// cxt.beginPath();
		// cxt.moveTo(w/2,h/2);//把触笔移动到什么坐标
		// cxt.lineTo(w/3,h/3);
		// cxt.strokeStyle="red";
		// cxt.stroke();//空心圆
	</script>
</html>